(()=>{"use strict";const e=require("express"),r=require("helmet"),s=require("morgan"),t=require("cors"),o=require("rotating-file-stream"),i=require("path"),n=require("dotenv"),u=require("mongoose"),c=new u.Schema({drink_id:{type:String,required:[!0,"drink_id is required"]},category_id:{type:String,required:[!0,"category_id is required"]},name:{type:String,required:[!0,"name is required"]},price:{type:Object,required:[!0,"name is required"],properties:{size_m:{type:Number},size_l:{type:Number,required:[!0,"name is required"]}}},status:{type:String,enum:["active","inactive"]},img:{type:String,require:[!0,"img is required"]},topping:{type:Boolean,require:[!0,"topping is required"]}}),a=u.model("Drink",c,"drink"),d={getAllProducts:async(e,r)=>{try{const e=await a.find();r.status(200).json({products:e})}catch(e){console.log(e),r.status(500).json({message:"HTTP 500 Internal server error"})}}},g=new e.Router;g.get("/",d.getAllProducts);const l=g,p=e();p.use("/products",l);const m=p;(0,n.config)(),(()=>{const e=process.env.MONGO_URL;u.Promise=global.Promise,u.connect(e,{useNewUrlParser:!0,useUnifiedTopology:!0}).then((()=>{console.log("Successfully connected to database")})).catch((()=>{console.log("Could not connect to database"),process.exit()}))})();const q=process.env.PORT||3e3,y="production"===process.env.NODE_ENVIRONMENT,v=i.resolve(),P=e();P.enable("trust proxy");const S=o.createStream("access.log",{interval:"1d",path:i.join(v,"logs")});P.use(y?s("combined",{stream:S}):s("tiny")),P.use(r()),P.use(t()),P.use((0,e.json)()),P.use("/api",m),P.get("/",((e,r)=>{r.status(404).json({message:"404, Page not Found!"})})),P.get("*",((e,r)=>{r.status(404).json({message:"404, Page not Found!"})})),P.listen(q,(()=>{console.log(`Server is listening on port ${q}`)}))})();